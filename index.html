<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red/Green Timer</title>
    <link rel="manifest" href="manifest.webmanifest">
    <style>
        :root {
            --background-color: #111111;
            --text-color: #FFFFFF;
            --red-color: #D32F2F;
            --green-color: #2E7D32;
            --button-color: #1976D2;
            --panel-color: #FFEB3B;
            --banner-color: #fff3cd;
            --banner-border-color: #ffe69c;
        }
        html, body {
            overscroll-behavior: none;
        }
        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            -webkit-tap-highlight-color: transparent;
        }
        .container {
            width: 90%;
            max-width: 480px;
            text-align: center;
            padding-top: 2vh;
        }
        h1 {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 0;
        }
        #version-label {
            font-size: 0.9em;
            color: #aaa;
            margin-top: 5px;
        }
        #setup-screen {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 2rem;
            width: 100%;
        }
        .form-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }
        .form-row label {
            font-size: 1.0rem;
            flex-shrink: 0;
            text-align: left;
        }
        input[type="number"] {
            -moz-appearance: textfield;
            font-size: 1.2rem;
            padding: 10px;
            border: none;
            border-radius: 5px;
            text-align: center;
            box-sizing: border-box;
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .spinner-lane {
            position: relative;
            flex-grow: 1;
        }
        .spinner-lane input {
             width: 100%;
             padding-right: 2.6em;
             background-image: linear-gradient(to right,
              rgba(255,255,255,0) 0,
              rgba(255,255,255,0) calc(100% - 2.6em),
              rgba(255,255,255,0.25) calc(100% - 2.6em),
              rgba(255,255,255,0.25) 100%);
        }
        #cycles-input {
            width: 90px;
            height: 42px;
            background-color: white;
            color: black;
        }
        .seconds-input-container {
            display: flex;
            gap: 1rem;
            flex-grow: 1;
        }
        .seconds-input {
            height: 42px;
            color: white;
        }
        #red-seconds-input { background-color: var(--red-color); }
        #green-seconds-input { background-color: var(--green-color); }
        .routine-container {
            display: flex;
            gap: 1rem;
            align-items: stretch;
        }
        #routine-selector {
            width: 60%;
            min-width: 220px;
            height: 42px;
            background-color: var(--panel-color);
            color: black;
            font-size: 1.0rem;
            border: none;
            border-radius: 5px;
            padding: 0 10px;
            text-align: center;
        }
        #routine-list-panel {
            flex-grow: 1;
            background-color: var(--panel-color);
            color: black;
            border-radius: 10px;
            padding: 10px;
            text-align: left;
            overflow-y: auto;
            max-height: 150px;
            font-size: 1.0rem;
        }
        #start-button {
            width: 100%;
            height: 56px;
            background-color: var(--button-color);
            color: white;
            font-size: 1.6em;
            font-weight: bold;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 1rem;
        }
        #timer-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: background-color 0.5s;
        }
        #countdown {
            font-size: clamp(96px, 37.5vh, 270px);
            font-weight: bold;
            line-height: 1;
        }
        #routine-name {
            font-size: clamp(48px, 10vh, 84px);
            font-weight: normal;
            padding: 0 20px;
            box-sizing: border-box;
        }
        #timer-controls {
            position: absolute;
            bottom: 30px;
            display: flex;
            gap: 1rem;
        }
        .timer-button {
            padding: 15px 30px;
            font-size: 1.2rem;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid white;
            border-radius: 5px;
            cursor: pointer;
        }
        #banner {
            display: none;
            background-color: var(--banner-color);
            border: 1px solid var(--banner-border-color);
            color: #664d03;
            padding: 1rem;
            border-radius: 5px;
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Red/Green Timer</h1>
        <p id="version-label">v0.3</p>

        <div id="setup-screen">
            <div id="banner">Couldn’t load routines.json — using built-in routine list.</div>
            <div class="form-row">
                <label for="cycles-input">Cycles (1–3)</label>
                <input type="number" id="cycles-input" min="1" max="3" value="1">
            </div>
            <div class="form-row">
                <label>Seconds</label>
                <div class="seconds-input-container">
                    <div class="spinner-lane">
                        <input type="number" id="red-seconds-input" class="seconds-input" placeholder="Red" min="1" value="20">
                    </div>
                     <div class="spinner-lane">
                        <input type="number" id="green-seconds-input" class="seconds-input" placeholder="Green" min="1" value="10">
                    </div>
                </div>
            </div>
            <div class="routine-container">
                <select id="routine-selector"></select>
                <div id="routine-list-panel"></div>
            </div>
            <button id="start-button">Start</button>
        </div>
    </div>

    <div id="timer-screen">
        <div id="countdown"></div>
        <div id="routine-name"></div>
        <div id="timer-controls">
            <button id="pause-resume-button" class="timer-button">Pause</button>
            <button id="stop-button" class="timer-button">Stop</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('sw.js')
                        .then(reg => console.log('Service Worker registered.', reg))
                        .catch(err => console.log('Service Worker registration failed: ', err));
                });
            }
            console.log("Red/Green Timer v0.3 loaded successfully.");

            const setupScreen = document.getElementById('setup-screen');
            const timerScreen = document.getElementById('timer-screen');
            const startButton = document.getElementById('start-button');
            const cyclesInput = document.getElementById('cycles-input');
            const redSecondsInput = document.getElementById('red-seconds-input');
            const greenSecondsInput = document.getElementById('green-seconds-input');
            const routineSelector = document.getElementById('routine-selector');
            const routineListPanel = document.getElementById('routine-list-panel');
            const countdownDisplay = document.getElementById('countdown');
            const routineNameDisplay = document.getElementById('routine-name');
            const pauseResumeButton = document.getElementById('pause-resume-button');
            const stopButton = document.getElementById('stop-button');
            const banner = document.getElementById('banner');

            let audioCtx;
            let audioUnlocked = false;

            function unlockAudio() {
                if (audioUnlocked || (audioCtx && audioCtx.state === 'running')) return;
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                const buffer = audioCtx.createBuffer(1, 1, 22050);
                const source = audioCtx.createBufferSource();
                source.buffer = buffer;
                source.connect(audioCtx.destination);
                source.start(0);
                audioUnlocked = true;
                console.log('Audio Context unlocked/resumed.');
                document.body.removeEventListener('click', unlockAudio);
                document.body.removeEventListener('touchstart', unlockAudio);
            }
            document.body.addEventListener('click', unlockAudio, { once: true });
            document.body.addEventListener('touchstart', unlockAudio, { once: true });

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && audioCtx && audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            });
            
            function playSound(freq, duration, startTime = 0) {
                if (!audioUnlocked || !audioCtx) return;
                if (audioCtx.state === 'suspended') audioCtx.resume();
                
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                
                const now = audioCtx.currentTime;
                const sTime = now + startTime;
                
                osc.frequency.setValueAtTime(freq, sTime);
                gain.gain.setValueAtTime(0.5, sTime);
                gain.gain.exponentialRampToValueAtTime(0.0001, sTime + (duration / 1000));
                
                osc.start(sTime);
                osc.stop(sTime + (duration / 1000));
            }

            let timerInterval;
            let currentPhase;
            let remainingTime;
            let currentCycle;
            let totalCycles;
            let redSeconds, greenSeconds;
            let routineItems;
            let isPaused = false;
            let beepTimeouts = [];
            let pauseTime;

            const fallbackRoutines = {
              "routines": {
                "Built-in Routine": ["Item A", "Item B", "Item C"],
                "Another Choice": ["X", "Y", "Z"]
              }
            };
            let allRoutines = {};

            async function loadRoutines() {
                try {
                    const response = await fetch('routines.json?ts=' + Date.now(), {cache:'no-store'});
                    if (!response.ok) throw new Error('Network response was not ok');
                    const data = await response.json();
                    allRoutines = data.routines;
                } catch (error) {
                    console.error('Failed to load routines.json:', error);
                    allRoutines = fallbackRoutines.routines;
                    banner.style.display = 'block';
                } finally {
                    populateRoutines();
                }
            }

            function populateRoutines() {
                routineSelector.innerHTML = '';
                for (const routineName in allRoutines) {
                    const option = document.createElement('option');
                    option.value = routineName;
                    option.textContent = routineName;
                    routineSelector.appendChild(option);
                }
                updateRoutineList();
            }

            function updateRoutineList() {
                const selectedRoutine = routineSelector.value;
                const items = allRoutines[selectedRoutine] || [];
                routineListPanel.innerHTML = items.map(item => `<div>- ${item}</div>`).join('');
            }
            
            routineSelector.addEventListener('change', updateRoutineList);

            function startTimer() {
                redSeconds = parseInt(redSecondsInput.value, 10);
                greenSeconds = parseInt(greenSecondsInput.value, 10);
                totalCycles = parseInt(cyclesInput.value, 10);

                if (isNaN(redSeconds) || redSeconds <= 0 || isNaN(greenSeconds) || greenSeconds <= 0) {
                    alert("Please enter a positive number of seconds.");
                    return;
                }
                
                unlockAudio();
                
                const selectedRoutineName = routineSelector.value;
                routineItems = allRoutines[selectedRoutineName] || [];

                currentCycle = 1;
                isPaused = false;
                setupScreen.style.display = 'none';
                timerScreen.style.display = 'flex';
                pauseResumeButton.textContent = 'Pause';
                
                startPhase('red', redSeconds);
            }

            function startPhase(phase, duration) {
                currentPhase = phase;
                remainingTime = duration;
                
                timerScreen.style.backgroundColor = (phase === 'red') ? 'var(--red-color)' : 'var(--green-color)';
                const routineItemIndex = (currentCycle - 1) * 2 + (phase === 'red' ? 0 : 1);
                routineNameDisplay.textContent = routineItems[routineItemIndex % routineItems.length] || (phase === 'red' ? 'Work' : 'Rest');
                
                updateCountdown();
                scheduleBeeps(duration);
                timerInterval = setInterval(tick, 1000);
            }

            function tick() {
                if (isPaused) return;
                
                remainingTime--;
                updateCountdown();

                if (remainingTime <= 0) {
                    nextPhase();
                }
            }

            function nextPhase() {
                clearInterval(timerInterval);
                clearBeeps();

                if (currentPhase === 'red') {
                    startPhase('green', greenSeconds);
                } else {
                    currentCycle++;
                    if (currentCycle > totalCycles) {
                        endRoutine();
                    } else {
                        startPhase('red', redSeconds);
                    }
                }
            }
            
            function updateCountdown() {
                countdownDisplay.textContent = remainingTime;
            }

            function scheduleBeeps(duration) {
                clearBeeps();
                for (let i = 1; i <= 5 && i <= duration; i++) {
                    const timeout = setTimeout(() => playSound(880, 120), (duration - i) * 1000);
                    beepTimeouts.push(timeout);
                }
            }

            function clearBeeps() {
                beepTimeouts.forEach(clearTimeout);
                beepTimeouts = [];
            }

            function pauseTimer() {
                if(isPaused) return;
                isPaused = true;
                pauseTime = Date.now();
                clearInterval(timerInterval);
                clearBeeps();
                pauseResumeButton.textContent = 'Resume';
            }

            function resumeTimer() {
                if(!isPaused) return;
                isPaused = false;
                pauseResumeButton.textContent = 'Pause';
                scheduleBeeps(remainingTime);
                timerInterval = setInterval(tick, 1000);
            }

            function stopTimer() {
                clearInterval(timerInterval);
                clearBeeps();
                timerScreen.style.display = 'none';
                setupScreen.style.display = 'flex';
            }
            
            function endRoutine() {
                playSound(660, 150, 0);
                playSound(880, 150, 0.18);
                playSound(1100, 150, 0.36);
                stopTimer();
            }

            startButton.addEventListener('click', startTimer);
            stopButton.addEventListener('click', stopTimer);
            pauseResumeButton.addEventListener('click', () => {
                isPaused ? resumeTimer() : pauseTimer();
            });
            
            loadRoutines();
        });
    </script>
</body>
</html>